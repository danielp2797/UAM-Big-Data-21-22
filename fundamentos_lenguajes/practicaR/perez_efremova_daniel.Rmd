---
title: "Fundamentos Lenguajes. Práctica 3"
author: "Daniel Pérez Efremova"
date: "8/28/2021"
output:
  pdf_document: default
  html_document: default
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = TRUE,
	message = TRUE,
	warning = TRUE
)
```
#### Declaración de librerías
```{r libraries, message=FALSE, warning=FALSE, include=TRUE}
library(tidyr)
library(dplyr)
library(stringr)
library(ggplot2)
```
## Ejercicios
#### 1. Leer el fichero comptagevelo2017.csv como un dataframe.
```{r read, message=FALSE, warning=FALSE, include=TRUE}
data <- read.csv("comptagevelo2017.xls", stringsAsFactors=F,
                 header=TRUE, encoding="ISO-8859-1", check.names=FALSE)
is.data.frame(data)
```
#### 2. Eliminar la columna 2 del dataframe
```{r drop, message=FALSE, warning=FALSE, include=TRUE}
data <- data[, -c(2)]
head(data[, seq(1,3)])
```

#### 3. Identificar cuales son las variables que están contenidas en el dataframe. A continuación, transformar ese dataframe para que cada columna represente una única variable.
```{r var, message=FALSE, warning=FALSE, include=TRUE}
colnames(data)
```
#### 4. Crear tres nuevas variables en el dataframe que contengan la información del día, mes y año respectiva mente (manteniendo la columna Date).
```{r date_cols, message=FALSE, warning=FALSE, include=TRUE}
data <- data %>%
  separate(col = Date, into = c("day", "month", "year"), sep = "/", remove = FALSE) %>%
      mutate_all(type.convert)

head(data[, seq(1, 4)])
```
#### 5. Convertir la columna Date a tipo date.
```{r date_new, message=FALSE, warning=FALSE, include=TRUE}
data$Date <- as.Date(data$Date, format="%d/%m/%Y")
head(data$Date)
class(data$Date)
```
#### 6. Modificar la columna de los distritos para eliminar los espacios alrededor de “/”.
```{r data_str, message=FALSE, warning=FALSE, include=TRUE}
colnames(data) <- gsub(" / ", "/", colnames(data))
colnames(data)
```
#### 7. Calcular el porcentaje de días en los que faltan datos para cada uno de los distritos.
```{r data_na, message=FALSE, warning=FALSE, include=TRUE}
rows=prod(dim(data))
sapply(data, function(x) round(100*sum(is.na(x))/rows, 2))
```
#### 8. Calcular el total de ciclistas que pasa por cada uno de los distritos a lo largo de todo el año.
```{r data_sum, message=FALSE, warning=FALSE, include=TRUE}
districts_data <- subset(data, select=!(colnames(data) %in% c("Date", "day", "month", "year")))
colSums(districts_data, na.rm=T)
```

#### 9. ¿Cuales son los cinco distritos con más número de ciclistas?
```{r data_stop, message=FALSE, warning=FALSE, include=TRUE}
sums_data <- colSums(districts_data, na.rm=T)

colnames(districts_data[, order(-sums_data)])[1:5]
```
#### 10. Realizar un gráfico de barras horizontales donde el eje x representa el total de ciclistas y el eje y los distritos.
```{r data_bar, message=FALSE, warning=FALSE, include=TRUE}
par(mar=c(5,12,0,4))
barplot(sums_data,
        horiz = T, 
        las=1,
        xlab="Número de ciclistas")
```
#### 11. Realizar un gráfico de lineas con la evolución mensual de ciclistas para cada distrito. En el gráfico tiene que aparecer una línea por distrito.
```{r data_line, message=FALSE, warning=FALSE, include=TRUE}
month_data_long <- data %>% 
    subset(select=!(colnames(data) %in% c("Date", "day", "year"))) %>%
        group_by(month) %>%
            summarize_all(sum, na.rm=T) %>%
                pivot_longer(-month, names_to= "district", values_to="ciclistas")

month_viz = ggplot(month_data_long, aes(x=month, y=ciclistas, color=district)) + 
geom_line() + 
scale_x_continuous(breaks=unique(month_data_long$month)) + 
labs(x='Mes', y='Ciclistas', title='Número de ciclistas por mes')
month_viz
```
#### 12. Ordenar las barras del gráfico del punto 10 de mayor (arriba) a menor (abajo) según el número de ciclistas.
```{r data_bar_sorted, message=FALSE, warning=FALSE, include=TRUE}
sums_data_sorted <- sums_data[order(sums_data)]

par(mar=c(5,12,0,4))
barplot(sums_data_sorted,
        horiz = T, 
        las=1, 
        xlab="Número de ciclistas")
```

#### 13. Añadir sobre el gráfico del punto 11 una linea de color azul y más ancha que el resto con la media de ciclistas por mes.
```{r data_line_blue, message=FALSE, warning=FALSE, include=TRUE}
month_means <- month_data_long %>%
            group_by(month) %>%
              summarize(media=mean(ciclistas, na.rm=T))

month_viz = month_viz+
geom_line(data=month_means, aes(x=month, y=media, color='Promedio'), size=3, color='Blue')+
scale_x_continuous(breaks=unique(month_data_long$month))

month_viz
```
#### 14. Realizar un gráfico de barras del número de ciclistas para cada día de la semana en cada uno de los cinco distritos con más ciclistas (usando facetas).
```{r data_top_bar_day, message=FALSE, warning=FALSE, include=TRUE}
top_districts <- colnames(districts_data[, order(colSums(-districts_data))])[1:5]

daily_data_long <- data %>% 
    select(c('Date', top_districts)) %>%
        mutate(weekday= ordered(weekdays(Date), levels=c("lunes", "martes", "miércoles", "jueves", 
"viernes", "sábado", "domingo"))) %>%
            group_by(weekday) %>%
                summarize_all(mean, na.rm=T) %>%
                  select(-Date) %>%
                      pivot_longer(-weekday, names_to= "district", values_to="ciclistas_media")

ggplot(daily_data_long, aes(x=weekday, y=ciclistas_media, fill=district))+
geom_bar(stat='identity', position=position_dodge(), ylab='número medio de ciclistas')+
labs(x='Día de la semana', y='Número medio de ciclistas', title='Cantidad media de ciclistas por día de la semana')+
facet_grid(district ~ .)

```

#### 15. Completar los missing values de la columna que representa el número de ciclistas con la media del resto de datos de esa variable pero agrupado por distrito y mes.
Persisten 61 valores perdidos. Esto se debe a que el distrito "Pont Jacques-Cartier" no tiene valores en los meses de Junio (30) y Julio (31).
```{r data_fill, message=FALSE, warning=FALSE, include=TRUE}
sapply(data, function(x) sum(is.na(x)))
impute.mean <- function(x) replace(x, is.na(x), round(mean(x, na.rm=T), 0))

data_rep <- data %>%
                pivot_longer(-c(Date, year, day, month),
                names_to= "district",              
                values_to="ciclistas") %>%
                    group_by(month, district) %>%
                        mutate(ciclistas=impute.mean(ciclistas)) %>%
                            pivot_wider(names_from = district, values_from = ciclistas)

sapply(data_rep, function(x) sum(is.na(x)))
```
#### 16. Leer el fichero localisationcompteursvelo2015.csv. Importante: la codificación del fichero no es UTF-8 sino ISO-8859-1.
En este ejercicio se usa el encoding latin1 (es el mismo que ISO-8859-1).
```{r data_read_latin, message=FALSE, warning=FALSE, include=TRUE}
data_loc <- read.csv("localisationcompteursvelo2015.xls", stringsAsFactors=T,
                 header=TRUE, encoding="latin1", check.names=FALSE)
is.data.frame(data_loc)
```
#### 17. Realizar un gráfico de puntos de las columnas coord X (eje x) y coord Y (eje y), con el color de los puntos representando la variable Type y la forma la variable Etat.
```{r data_plot_scatter, message=FALSE, warning=FALSE, include=TRUE}
ggplot(data_loc, aes(x=coord_X, y=coord_Y, color=Type, shape=Etat)) +
  geom_point()
```
#### 18. Hacer un join de los dos dataframes por las columnas con los nombres del districto en el primer dataframe y “nom comptage” en el segundo.
Para poder unir las tablas usando como clave los distritos, deben tener exactamente los mismos nombres en las dos tablas. En primer lugar se modifican los nombres para que coincidan. Luego se pivota la tabla que contiene los distritos como columna para poder unirlos, se efectúa la unión y, finalmente, se deshace el pivote.
```{r data_join, message=FALSE, warning=FALSE, include=TRUE}
data_long <- pivot_longer(data, -c('Date', 'day', 'month', 'year'), values_to='ciclistas', names_to='nom_comptage')
head(data)
data_long
data_loc

data_joined <- merge(x=data_long, y=data_loc, by='nom_comptage', all.x=T)

data_joined
data_loc_joined <- pivot_wider(data_joined, names_from=nom_comptage, values_from=ciclistas)

head(data_loc_joined[order(data_loc_joined$Date), ])
```
#### 19. Ver qué districtos del primer dataframe no se encuentran en el segundo
Sabiendo que el fichero comptagevelo2017.csv contiene todos los nombres de distrito como columna, basta intersecar una lista con todos los distritos con los distritos que contiene localisationcompteursvelo2015.csv en la columna nom_comptage.
```{r data_intersect, message=FALSE, warning=FALSE, include=TRUE}
districts_list <- unique(data_long$nom_comptage) # los nombres de distrito provienen del dataframe pivotado
data_loc_districts <- unique(data_loc$nom_comptage)

common <- intersect(data_districts, data_loc_districts)
not_common <- districts_list[!(districts_list %in% common)]
not_common
```
#### 20. Realizar un gráfico de puntos del dataframe resultante del ejercicio 18 de las columnas coord X (eje x) y coord Y (eje y), donde el tamaño de los puntos representa el número total de ciclistas que pasaron por ese districto a lo largo de todo el año.
Solo aparecen los distritos en común entre los dos conjuntos de datos. EL resto no puede reprersentarse por las variables de coordenadas.
```{r data_graf_anu, message=FALSE, warning=FALSE, include=TRUE}
data_joined_year <- data_joined %>%
                        select(c('coord_X', 'coord_Y', 'nom_comptage', 'ciclistas'))

data_agg_year <- aggregate(ciclistas ~ ., data=data_joined_year, FUN=sum)

ggplot(data_agg_year, aes(x=coord_X, y=coord_Y, size=ciclistas, color=nom_comptage)) +
  geom_point()
```











































