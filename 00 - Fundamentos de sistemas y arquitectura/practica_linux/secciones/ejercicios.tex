\section{Aclaraciones}
Este documento es la memoria de la práctica. En cada apartado se detallan los razonamientos que llevan a la solución de los ejercicios y las ejecuciones en Shell.\\\\
Se ha empleado una máquina virtual mediante Oracle VirtualBox 6.1 con la distribución de Linux Ubuntu 20.04 por preferencias personales, aunque para los ejercicios que lo requerían, se ha utilizado la provista en el curso. 
\section{Ejercicios}
\subsection*{ejercicio 1}
\addcontentsline{toc}{subsection}{\protect\numberline{}ejercicio 1}%
En primer lugar, se ejecuta el comando \textbf{man} junto a \textbf{ls} y se obtiene su documentación. En el código \ref{ls_doc} se muestran las entradas de interés.
\begin{lstlisting}[language=bash,caption={Documentación del comando ls}, label={ls_doc}]
(base) daniel@daniel-VirtualBox:~$ man ls
...
-c	with -lt: sort by, and show, ctime (time of 
last modification of file status information); with -l: 
show  ctime and sort by name; otherwise: sort by ctime,
newest first
...
-t	sort by modification time, newest first
...
\end{lstlisting}

Se concluyen dos aspectos:
\begin{enumerate}
	\item La opción \textbf{-t} muestra los archivos y directorios del directorio seleccionado ordenados por fecha de modificación (sin imprimirla) desde el más nuevo al más antiguo.
	\item La opción \textbf{-c} tiene varios comportamientos dependiendo de las opciones adicionales seleccionadas. Si se selecciona \textbf{-lt} se imprimirán los directorios, archivos y su fecha de última modificación. Además, aparecerán ordenados por última fecha de modificación (la más nueva primero). Si se selecciona \textbf{-l} se imprimen los archivos, directorios y su fecha de última de última modificación, pero aparecerán ordenados alfabéticamente. Por último, si no se especifican otras opciones, se imprimirán los archivos y directorios ordenados por la fecha de última modificación (sin imprimirla).  
\end{enumerate}
En segundo lugar, se realiza el mismo proceso anterior con el comando \textbf{cat}. En el código \ref{cat_doc} se muestran las entradas de interés
\begin{lstlisting}[language=bash,caption={Documentación del comando cat}, label={cat_doc}]
(base) daniel@daniel-VirtualBox:~$ man cat
...
-n, --number 
	number all output lines
...
-T, --show-tabs
	display TAB characters as ^I
...
\end{lstlisting}
Se concluyen dos aspectos:
\begin{enumerate}
	\item La opción \textbf{-n} numera las líneas al imprimir la concatenación de archivos.
	\item La opción \textbf{-\textrm{T}} sustituye las tabulaciones por $^\wedge \textrm{I}$ al imprimir la concatenación de archivos. 
\end{enumerate}
\subsection*{ejercicio 2}
\addcontentsline{toc}{subsection}{\protect\numberline{}ejercicio 2}%
En el código \ref{rec_nombres} se ve la \textit{pipeline} solución al ejercicio.\\\\
El primer paso es concatenar los archivos (en este caso uno) con el comando \textbf{cat}. Después, se ordenan los valores mediante \textbf{sort} y se emplea el comando \textbf{uniq} con la bandera \textbf{-c} para contar los duplicados en filas adyacentes. Al haber ordenado el fichero, el comando contará el número de ocurrencias de cada valor. Para terminar, ordenamos el resultado del recuento mediante \textbf{sort} y las banderas \textbf{-nr} para que ordene por los valores númericos en sentido descendente. De este modo, obtenemos el resultado ordenado del nombre más frecuente al menos frecuente. La última parte con el comando \textbf{head} y la opción \textbf{-n} se encarga de mostrar las 5 primeras filas del resultado por pantalla. 
\begin{lstlisting}[language=bash,caption={Recuento de valores en nombres.txt}, label={rec_nombres}]
(base) daniel@daniel-VirtualBox:~/Desktop/UAM_master_big_d
ata/fundamentos_sistemas/practica1/material_practica$ cat 
nombres.txt | sort | uniq -c | sort -nr | head -n 5

1742 Victoria
1681 Maria
1678 Alberto
1645 Juan
1631 Ana
\end{lstlisting}
\subsection*{ejercicio 3}
\addcontentsline{toc}{subsection}{\protect\numberline{}ejercicio 3}%
En el código \ref{path} se ve la solución del ejercicio.\\\\
Se usa el comando \textbf{find} sobre el directorio raíz ($\sim$) para encontrar todas las coincidencias en el sistema con el archivo \textit{firefox.desktop}.
\begin{lstlisting}[language=bash,caption={Búsqueda del archivo firefox.desktop}, label={path}]
bigdata@bigdata:~$ find ~ -name "firefox.desktop"
/home/bigdata/Desktop/firefox.desktop
\end{lstlisting}
\subsection*{ejercicio 4}
\addcontentsline{toc}{subsection}{\protect\numberline{}ejercicio 4}%
En el código \ref{hour} se muestra el resultado. Se usa el comando \textbf{date} seguido del formato de la cadena. 
\begin{lstlisting}[language=bash,caption={Fecha en formato}, label={hour}]
(base) daniel@daniel-VirtualBox:~$ date +"%Y-%m-%d %H:%M:
%S" 
2021-08-14 20:23:46
\end{lstlisting}
\subsection*{ejercicio 5}
\addcontentsline{toc}{subsection}{\protect\numberline{}ejercicio 5}%
En el código \ref{vm} se ve el script \textit{vm\_info.sh} que resuelve el ejercicio.\\\\
Para la información del procesador se utiliza el psudoarchivo del sistema \textbf{/proc/cpuinfo} y mediante el comando \textbf{grep} se encuentra la línea del modelo de procesador. Para la memoria se usa el comando \textbf{free} con la opción \textbf{--giga} para que se imprima el resultado en GB. Para el espacio en disco en la partición /, se usa el comando \textbf{df} y la bandera \textbf{-H} sobre el directorio /, así se muestra en formato humano y con las unidades en GB.
\begin{lstlisting}[language=bash,caption={Script de información de la máquina virtual}, label={vm}]
#!/bin/sh
cat /proc/cpuinfo | grep "model name"
free --giga
df -H / 
\end{lstlisting}
En el código \ref{test_script} se ve el test del script.
\begin{lstlisting}[language=bash,caption={Test de vm\_info.sh}, label={test_script}]
(base) daniel@daniel-VirtualBox:~$ bash vm_info.sh
model name: Intel(R) Core(TM) i5-8265U CPU @ 1.60GHz

     total used free shared buff/cache available
Mem:     3    1    0      0          2         2
Swap:    1    0    1

Filesystem      Size  Used Avail Use% Mounted on
/dev/sda5        28G   24G  2,0G  93% /
\end{lstlisting}
\subsection*{ejercicio 6}
\addcontentsline{toc}{subsection}{\protect\numberline{}ejercicio 6}%
En el código \ref{ls_files} se ve el script \textit{check\_ext.sh} que resuelve el ejercicio.\\\\
Se define el directorio actual mediante el comando \textbf{pwd} y se recoge la extensión a buscar en una variable. Después, se itera sobre todos los archivos del directorio, comprobando con un delimitador si tiene la extensión argumento. En caso afirmativo se imprime el nombre completo del archivo con su extensión. Si no se pasa un argumento el script termina.  
\begin{lstlisting}[language=bash,caption={Script para listar archivos con una extensión dada}, label={ls_files}]
#!/bin/bash
################################################
#Input: extension de archivo (sin punto)
#Output: listado de archivos
#Descrip: imprime los archivos del dir actual con la ext
# de entrada
################################################

dir=$pwd*
exten=$1
if [ $# -lt 1 ]; then
echo "No extension provided..."
else

for file in $dir*; do
file_exten=${file##*.}
if [[ $exten == $file_exten ]];then
echo $file
fi
done
fi

\end{lstlisting}
En el código \ref{test_ext} se muestra un test de las funcionalidades del programa.
\begin{lstlisting}[language=bash,caption={Test del script \textit{check\_ext.sh}}, label={test_ext}]
(base) daniel@daniel-VirtualBox:~/Desktop/UAM_master_big_
data/fundamentos_sistemas/practica1/entrega$ ls
build  cabecera  check_ext.sh  main.tex  secciones  
vm_info.sh

(base) daniel@daniel-VirtualBox:~/Desktop/UAM_master_big_
data/fundamentos_sistemas/practica1/entrega$ 
bash check_ext.sh sh
check_ext.sh
vm_info.sh

(base) daniel@daniel-VirtualBox:~/Desktop/UAM_master_big_
data/fundamentos_sistemas/practica1/entrega$ 
bash check_ext.sh txt

(base) daniel@daniel-VirtualBox:~/Desktop/UAM_master_big_
data/fundamentos_sistemas/practica1/entrega$ 
bash check_ext.sh 
No extension provided...
\end{lstlisting}
\subsection*{ejercicio 7}
\addcontentsline{toc}{subsection}{\protect\numberline{}ejercicio 7}%
En el código \ref{sys} se ve la \textit{pipeline} solución del ejercicio.\\\\
Se usa el comando \textbf{ps} con las banderas \textbf{-aux} para imprimir los procesos de todos los usuarios, extendidos y que tengan o no una terminal asociada. Después, se usa el comando \textbf{grep} para encontrar el proceso pedido. Inmediatamente se vuelve a buscar el proceso excluyendo el propio proceso de búsqueda de \textbf{grep}. Finalmente, usando \textbf{awk} se imprime la primera columna que corresponde al usuario que ejecuta el proceso.
\begin{lstlisting}[language=bash,caption={Usuario que ha ejecutado el proceso rsyslogd}, label={sys}]
(base) daniel@daniel-VirtualBox:~$ ps -aux | grep rsyslogd
 | grep -v "grep" | awk '{print $1}'
syslog
\end{lstlisting}
Se observa que es el usuario syslog, uno de los usuarios del sistema con permisos restringidos a únicamente escribir los mensajes log del kernel, consola u otros (Principio de mínimo privilegio). 
\subsection*{ejercicio 8}
\addcontentsline{toc}{subsection}{\protect\numberline{}ejercicio 8}%
En el código \ref{mlt} se ve la resolución del ejercicio.\\\\
Se utiliza el comando \textbf{multitime} con la opción \textbf{-n} para indicar el número de ejecuciones a evaluar (en este caso $4$).
\begin{lstlisting}[language=bash,caption={Tiempo de ejecución del script \textit{calculaFG.bash}}, label={mlt}]
(base) daniel@daniel-VirtualBox:~/Desktop/UAM_master_big
_data/fundamentos_sistemas/practica1/material_practica$ 
multitime -n 4 bash calculaFG.bash

===> multitime results
1: bash calculaFG.bash
      Mean Std.Dev.   Min Median   Max
real 6.646    0.391 6.279  6.508 7.289       
user 6.420    0.288 6.151  6.329 6.869       
sys  1.556    0.211 1.386  1.463 1.913      
\end{lstlisting}
Se intentó desarrollar un script que solo utilizase recursos internos mediante el comando \textbf{time} pero debido a la complejidad que presentaba se acudió a \textbf{multitime}\footnote{Documentación del comando \textbf{multitime}: \url{https://manpages.debian.org/testing/multitime/multitime.1.en.html}. Se puede instalar fácilmente mediante la instrucción \textit{sudo apt-get install -y multitime}.}, que ya implementa la funcionalidad pedida.
\subsection*{ejercicio 9}
\addcontentsline{toc}{subsection}{\protect\numberline{}ejercicio 9}%
En el código \ref{par} se ve el nuevo script que resuelve el ejercicio y en el código \ref{test_par} el nuevo cálculo del tiempo de ejecución. El nuevo código paralelizado es \textit{calculaFGpar.bash}.
\begin{lstlisting}[language=bash,caption={Modificación del script \textit{calculaFG.bash}}, label={par}]
#!/bin/bash
./factorial.bash 1000 > /dev/null &
./factorial.bash 1001 > /dev/null &
./factorial.bash 1002 > /dev/null &
./factorial.bash 1003 > /dev/null &
wait    
\end{lstlisting}
Se ha añadido al final de cada línea \textbf{\&} para poner cada línea de ejecución en background e inmediatamente pasar a la siguiente línea. Para evitar que termine la ejecución del script después de poner todas las líneas en bakcground, se pone el comando \textbf{wait}.
\begin{lstlisting}[language=bash,caption={Tiempo de ejecución del script \textit{calculaFGpar.bash}}, label={test_par}]
(base) daniel@daniel-VirtualBox:~/Desktop/UAM_master_big_
data/fundamentos_sistemas/practica1/material_practica$
 multitime -n 4 bash calculaFGpar.bash

===> multitime results
1: bash calculaFGpar.bash
      Mean Std.Dev.   Min Median   Max
real 3.846    0.309 3.658  3.672 4.380       
user 6.090    0.373 5.847  5.890 6.734       
sys  1.480    0.234 1.335  1.350 1.884   
\end{lstlisting}
Se observa en el tiempo ``real'' de la ejecución es aproximadamente la mitad de tiempo que sin paralelizar.\\\\
Si durante la ejecución del script se examinan los procesos en curso (código \ref{test_proc}), se ve que el sistema tiene cuatro procesos en background asociados al comando \textit{bash calculaFGpar.bash} y ocupando memoria. Para ello basta utilizar el comando \textbf{bf} con la abreviatura \textbf{aux} y filtrar por la cadena ``calculaFGpar''.
\begin{lstlisting}[language=bash,caption={Procesos en curso durante la ejecución paralela de \textit{calculaFGpar.bash}}, label={test_proc}]
(base) daniel@daniel-VirtualBox:~/Desktop/UAM_master_big_
data/fundamentos_sistemas/practica1/material_practica$
ps aux | grep calculaFGpar | grep "grep" -v
 
daniel 699158  0.0  0.0  18132 3476 pts/2 S+ 15:52 0:00 
bash calculaFGpar.bash 
daniel 699159  4.0  0.0  18392 2300 pts/2 S+ 15:52 0:00 
bash calculaFGpar.bash
daniel 699160  4.0  0.0  18392 2304 pts/2 S+ 15:52 0:00 
bash calculaFGpar.bash
daniel 699161  4.5  0.0  18392 2304 pts/2 S+ 15:52 0:00 
bash calculaFGpar.bash
daniel 699162  4.5  0.0  18392 2304 pts/2 S+ 15:52 0:00 
bash calculaFGpar.bash 
\end{lstlisting}
\subsection*{ejercicio 10}
\addcontentsline{toc}{subsection}{\protect\numberline{}ejercicio 10}%
En el código \ref{dir_proc} se ve el código solución al ejercicio.\\\\
Basta utilizar el comando \textbf{taskset} seguido de la opción \textbf{-c} con el valor $1$ para indicar que se ejecute el script en el core número 1.
\begin{lstlisting}[language=bash,caption={Ejecución del script \textit{calculaFGpar.bash} en el core 1}, label={dir_proc}]
(base) daniel@daniel-VirtualBox:~/Desktop/UAM_master_big_
data/fundamentos_sistemas/practica1/material_practica$ 
taskset -c 1 bash calculaFGpar.bash
\end{lstlisting}
A modo de comprobación (código \ref{comp_core}), se paran los procesos y se buscan sus PID mediante el comando \textbf{ps}, como en el ejercicio anterior. Después, se comprueba nuevamente con \textbf{ps} en qué core se están ejecutando dichos procesos.
\begin{lstlisting}[language=bash,caption={Comprobación de la ejecución de \textit{calculaFGpar.bash}}, label={comp_core}]
(base) daniel@daniel-VirtualBox:~/Desktop/UAM_master_big_
data/fundamentos_sistemas/practica1/material_practica$
ps aux | grep calculaFGpar | grep "grep" -v

daniel 858163 0.0 0.0 18132 3604 pts/2 T 16:47 0:00 
bash calculaFGpar.bash
daniel 858164 0.4 0.0 18264 2300 pts/2 T 16:47 0:00 
bash calculaFGpar.bash
daniel 858165 0.4 0.0 18264 2296 pts/2 T 16:47 0:00 
bash calculaFGpar.bash
daniel 858166 0.4 0.0 18264 2300 pts/2 T 16:47 0:00 
bash calculaFGpar.bash
daniel 858167 0.4 0.0 18264 2296 pts/2 T 16:47 0:00 
bash calculaFGpar.bash

(base) daniel@daniel-VirtualBox:~/Desktop/UAM_master_big_
data/fundamentos_sistemas/practica1/material_practica$ 
ps -o pid,psr,comm -p 858164

   PID PSR COMMAND
858164   1    bash

\end{lstlisting}
\subsection*{ejercicio 11}
\addcontentsline{toc}{subsection}{\protect\numberline{}ejercicio 11}%
En los códigos \ref{mem_res} y \ref{prlimit_test} se ven dos posibles soluciones al ejercicio.\\\\
Se puede usar el comando \textbf{ulimit} con la opción \textbf{-v} (memoria virtual). A continuación se presenta un pequeño test concatenando el script \textit{calculaFG.bash}. 
\begin{lstlisting}[language=bash,caption={Restricción de memoria máxima en la Shell actual con ulimit}, label={mem_res}]
(base) daniel@daniel-VirtualBox:~/Desktop/UAM_master_big_
data/fundamentos_sistemas/practica1/material_practica$ 
ulimit -v

unlimited

(base) daniel@daniel-VirtualBox:~/Desktop/UAM_master_big_
data/fundamentos_sistemas/practica1/material_practica$ 
cat calculaFG.bash

#!/bin/bash
./factorial.bash 1000 > /dev/null
./factorial.bash 1001 > /dev/null
./factorial.bash 1002 > /dev/null
./factorial.bash 1003 > /dev/null
 
(base) daniel@daniel-VirtualBox:~/Desktop/UAM_master_big_
data/fundamentos_sistemas/practica1/material_practica$ 
ulimit -v 0

(base) daniel@daniel-VirtualBox:~/Desktop/UAM_master_big_
data/fundamentos_sistemas/practica1/material_practica$ 
cat calculaFG.bash

Segmentation fault
\end{lstlisting}
Esto limitaría la memoria en una shell concreta durante toda la sesión. Sin embargo, se puede ser más preciso mediante el comando \textbf{prlimit}\footnote{Documentación del comando \textbf{prlimit}: \url{https://man7.org/linux/man-pages/man1/prlimit.1.html}.}. Este comando permite ejecutar un comando concreto estableciendo los recursos pasados como argumento y manteniendo los recursos de la shell por defecto. A continuación se ve un test similar al anterior.
\begin{lstlisting}[language=bash,caption={Restricción de memoria máxima en la Shell actual con prlimit}, label={prlimit_test}]
(base) daniel@daniel-VirtualBox:~/Desktop/UAM_master_big_
data/fundamentos_sistemas/practica1/material_practica$ 
prlimit --as=0 cat calculaFG.bash

Segmentation fault

(base) daniel@daniel-VirtualBox:~/Desktop/UAM_master_big_
data/fundamentos_sistemas/practica1/material_practica$
prlimit --as=unlimited cat calculaFG.bash
 
#!/bin/bash
./factorial.bash 1000 > /dev/null
./factorial.bash 1001 > /dev/null
./factorial.bash 1002 > /dev/null
./factorial.bash 1003 > /dev/null 
\end{lstlisting}
\subsection*{ejercicio 12}
\addcontentsline{toc}{subsection}{\protect\numberline{}ejercicio 12}%
En el código \ref{user} se ve la solución al ejercicio.\\\\
La variable de entorno es USER y basta escribir el comando \textbf{echo} para imprimirla por pantalla. Tiene el valor ``big data''.
\begin{lstlisting}[language=bash,caption={variable de entorno con usuario el actual}, label={user}]
bigdata@bigdata:~$ echo $USER

bigdata
\end{lstlisting}
\begin{lstlisting}[language=bash,caption={variable de entorno con usuario el actual}, label={user}]
bigdata@bigdata:~$ echo $USER
	
bigdata
\end{lstlisting}
\subsection*{ejercicio 13}
\addcontentsline{toc}{subsection}{\protect\numberline{}ejercicio 13}%
En el código \ref{cron_sch} se ve la solución al ejercicio.\\\\
Basta poner la fecha en el formato adecuado y la ruta en valor absoluto al script. En este caso, el script esta guardado en el directorio raíz en una carpeta llamada scripts y se ejecuta con el comando bash. Para escribir incrementalmente en \textit{stats.txt} se direcciona la salida estándar de la ejecución con $>>$.
\begin{lstlisting}[language=bash,caption={Planificación con crontab}, label={cron_sch}]
0 14 * * 5 bash /home/scripts/vm_info.sh >> stats.txt
\end{lstlisting}
\subsection*{ejercicio 14}
\addcontentsline{toc}{subsection}{\protect\numberline{}ejercicio 14}%
Se crea la carpeta entregable (perez\_efremova\_daniel\_fs\_p1) con el comando \textbf{tar} y se comprime con \textbf{cvzf}.
\begin{lstlisting}[language=bash,caption={Compresión para la entrega}, label={tar_entrega}]
(base) daniel@daniel-VirtualBox:~/Desktop/UAM_master_big_
data/fundamentos_sistemas/practica1/entrega$ 
tar cvcf perez_efremova_daniel_fs_p1.tar.bz2 
perez_efremova_daniel_fs_p1.pdf check_ext.sh 
calculaFGpar.bash vm_info.sh 
\end{lstlisting}